---
title: JIT
date: 2022-03-13
publish: false
---

### 1、概念

 Java原先把源代码编译为字节码在虚拟机上执行，这样执行速度较慢。而HotSpot将常用的部分代码（热点代码）编译为本地（原生，native）代码，这样显著提高了性能。

### 2、详解

**HotSpot包含一个解释器和两个编译器（client和server，二选一的），解释与编译混合执行的模式，默认启动解释执行**

`解释器`：解释器用来解释.class文件（字节码文件），java是解释语言

`编译器`: java源代码被编译成.class文件（字节码），java字节码在运行时可以被动态编译（JIT）成本地代码（前提是解释与编译混合执行模式，且虚拟机不是刚刚启动）

* server启动慢，占用内存多，执行效率高，适用于服务器端应用；

* client启动快，占用内存小，执行效率没有server快，默认情况下不进行动态编译，适用于桌面应用程序。

### 3、动态编译

**Hotspot对bytecode的编译不是在虚拟机运行前编译的，是在虚拟机运行字节码的过程中编译的**。HotSpot里运行着一个监视器（Profile Monitor），用来监视程序的运行状况。

java字节码（class文件）是以解释的方式被加载到虚拟机中(默认启动时解释执行)。 程序运行过程中，那一部分运用频率大，那些对程序的性能影响重要。**对程序运行效率影响大的代码，称为热点（hotspot），HotSpot会把这些热点动态地编译成机器码（native code），同时对机器码进行优化，从而提高运行效率**。对那些较少运行的代码，HotSpot就不会把他们编译。

HotSpot对字节码有三层处理：

不编译(字节码加载到虚拟机中时的状态。也就是当虚拟机执行的时候再编译)；

编译(把字节码编译成本地代码。虚拟机执行的时候已经编译好了，不要再编译了)；

编译并优化（不但把字节码编译成本地代码，而且还进行了优化）。

至于那些程序那些不编译，那些编译，那些优化，则是由监视器（Profile Monitor）决定。

### 4、为什么不静态编译？ 

动态编译器也在许多方面比静态编译器优越。静态编译器通常很难准确预知程序运行过程中究竟什么部分最需要优化。

**函数调用都是很浪费系统时间的，因为有许多进栈出栈操作。因此有一种优化办法，就是把原来的函数调用，通过编译器的编译，改成非函数调用，把函数代码直接嵌到调用处，变成顺序执行。**

 面向对象的语言支持多态，静态编译无法确定程序调用哪个方法，因为多态是在程序运行中确定调用哪个方法。

### JIT即时编译

1、动态编译：指的是“在运行时进行编译”；与之相对的是事前编译，也叫静态编译；

2、JIT编译（just-in-time compliation）狭义来说是当某段代码即将第一次被执行时进行编译，因此叫“即时编译”。JIT是动态编译的一种特例。JIT编译一词后来被泛化，时常与动态编译等价；但要注意广义与狭义的JIT编译所指的区别

3、自适应编译：也是一种动态编译，但它通常执行的时机比JIT编译迟。先让程序以某种方式运行起来，收集一些信息之后再做动态编译。这样编译可以更加优化。

概述

JVM运行原理

![在这里插入图片描述](https://img-blog.csdnimg.cn/bece9c0440c147a99079a9beb0a24590.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_10,color_FFFFFF,t_70,g_se,x_16)

在部分商用虚拟机中（如HotSpot），Java程序最初是通过解释器（Interpreter）进行解释执行的，**当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器**（Just In Time Compiler，下文统称JIT编译器）。

即时编译器并不是虚拟机必须的部分，Java虚拟机规范并没有规定Java虚拟机内必须要有即时编译器存在，更没有限定或指导即时编译器应该如何去实现。但是，即时编译器编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，它也是虚拟机中最核心且最能体现虚拟机技术水平的部分。

由于Java虚拟机规范并没有具体的约束规则去限制即时编译器应该如何实现，所以这部分功能完全是与虚拟机具体实现相关的内容，如无特殊说明，我们提到的编译器、即时编译器都是指Hotspot虚拟机内的即时编译器，虚拟机也是特指HotSpot虚拟机。

### 即时编译器与java编译器不同：

**java编译器（在windows下，javac.exe）将源代码（java文件）编译为字节码（bytecode），存放在class文件中。**

字节码不能直接在机器上执行，而是通过虚拟机（windows下是java.exe）执行。具体的执行方式有两种：

1. 一般情况下解释执行。解释执行并不是“解释为用c++语言写成的程序”，而是jvm把字节码看成脚本，根据字节码中的指令，由JVM去调用实际的本地方法。 

2. 在打开了JIT参数的前提下，jvm会把执行过程中发现的热点位置，由jvm内部的即时编译器编译为本地机器码直接执行。
即时编译器是对JVM进行的优化，将频繁执行的热点代码直接编译为本地的机器码，这样在执行这些代码时，就不需要去解释执行了，可以直接调用

### 为什么HotSpot虚拟机要使用解释器与编译器并存的架构？

尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机（如HotSpot），都同时包含解释器和编译器。解释器与编译器两者各有优势：

当程序需要迅速启动和执行的时候，解释器（`解释器的执行与编译器无关`）可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。

`当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释器执行节约内存，反之可以使用编译执行来提升效率`。此外，如果编译后出现“罕见陷阱”，可以通过逆优化退回到解释执行。

![在这里插入图片描述](https://img-blog.csdnimg.cn/48a6218a13c04818b8d9e1cebcde1e96.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_10,color_FFFFFF,t_70,g_se,x_16)

### 编译的时间开销

解释器的执行，抽象的看是这样的：

* 输入的代码 -> [ 解释器 解释执行 ] -> 执行结果

而要JIT编译然后再执行的话，抽象的看则是：

*   输入的代码 -> [ 编译器 编译 ] -> 编译后的代码 -> [ 执行 ] -> 执行结果

说JIT比解释快，其实说的是“执行编译后的代码”比“解释器解释执行”要快，并不是说“编译”这个动作比“解释”这个动作快。

JIT的快在于，我们将热点的代码直接编译为平台可以执行的机器码，这样以后再调用该段程序时的效率会大大提高。

### 编译的空间开销

**对于一般的java方法而言，编译后的代码大小相对于字节码的大小，膨胀比达到10x是很正常的。同上面说的一样，这里的空间开销也是，只有对频繁执行的代码才值得编译，如果把所有代码都编译会显著增加代码所占的空间，导致“代码爆炸”**

这里解释了为什么有些JVM会选择不总是做JIT编译，而是选择使用解释器+JIT编译器的混合执行引擎。

### 为何HotSpot虚拟机要实现两个不同的即时编译器？

HotSpot虚拟机中内置了两个即时编译器：Client Complier和Server Complier，简称为C1、C2编译器，分别用在客户端和服务端。`目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作`。程序使用哪个编译器，取决于虚拟机运行的模式。HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用“-client”或“-server”参数去强制指定虚拟机运行在Client模式或Server模式。

`用Client Complier获取更高的编译速度，用Server Complier 来获取更好的编译质量.`为什么提供多个即时编译器与为什么提供多个垃圾收集器类似，都是为了适应不同的应用场景。

### 哪些程序会被编译为本地代码？如何编译为本地代码？

程序中的代码只有是`热点代码`时，才会编译为本地代码，那么什么是热点代码呢？


运行过程中会被即时编译器编译的“热点代码”有两类：

1、被多次调用的方法。

2、被多次执行的循环体。

两种情况，编译器都是以整个方法作为编译对象。 这种编译方法因为编译发生在方法执行过程之中，因此形象的称之为栈上替换（On Stack Replacement，OSR），即方法栈帧还在栈上，方法就被替换了。

### 如何判断一段代码是不是热点代码？

要知道方法或一段代码是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）。

目前主要的热点探测方式有以下两种：

（1）基于采样的热点探测

采用这种方法的虚拟机会周期性地检查各个线程的栈顶，`如果发现某些方法经常出现在栈顶，那这个方法就是“热点方法”`。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。

（2）基于计数器的热点探测

`采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”`。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。

### 如何编译为本地代码？

Server Compiler和Client Compiler两个编译器的编译过程是不一样的。

对Client Compiler来说，它是一个简单快速的编译器，主要关注点在于局部优化，而放弃许多耗时较长的全局优化手段。

而Server Compiler则是专门面向服务器端的，并为服务端的性能配置特别调整过的编译器，是一个充分优化过的高级编译器。

### 总结

1、即时编译器的优点在于，对于频繁调用的方法或者代码块，我们通过即时编译的手段，将其编译为与平台相关的机器码，对于一次执行过程而言，即是编译执行的执行速度不如解释执行，但是对于后续执行重复的代码，效率会高的多；

2、即时编译的缺点在于：即时编译生成的代码大小是字节码大小的数倍，对于内存的消耗很大

3、即时编译器分为Client和server两种：

Client的启动快，占用内存小，但是执行效率比server小，适用于客户端

server的启动慢，占用内存大，但是执行效率比client快，适用于服务器端

4、如何判断一段代码是否为热点代码？

* 基于采样的热点探测技术：

周期性的观察各项线程的栈顶，找到经常出现在栈顶的方法，标记为热点方法

优点：简单；缺点：不能精确的确定代码的执行次数

* 基于计数器的热点探测技术：

给每个代码块或是方法建立计数器，然后统计方法的执行次数，超过阈值则标记为热点代码

优点：能够精确严谨的统计出热点代码；缺点：麻烦

