---
title: LC第87场双周赛
date: 2022-09-18
categories: 
 - 双周赛
---

### 一、[统计共同度过的日子数](https://leetcode.cn/problems/count-days-spent-together/)

```java
class Solution {
    int[] month = new int[]{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int get(String x){
        String[] sp = x.split("-");
        int res = 0;
        int m = Integer.parseInt(sp[0]);
        int d = Integer.parseInt(sp[1]);
        for(int i = 1; i < m; i++) {
            res += month[i];
        }
        return res + d;
    }
    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {
        int a = get(arriveAlice);
        int b = get(leaveAlice);
        int c = get(arriveBob);
        int d = get(leaveBob);
        return Math.max(0, Math.min(b, d) - Math.max(a, c) + 1);
    }
}
```

### 二、[运动员和训练师的最大匹配数](https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/)

```java
class Solution {
    public int matchPlayersAndTrainers(int[] players, int[] trainers) {
        int n = players.length;
        Arrays.sort(players);
        List<Integer> list = new ArrayList<>();
        for(int t: trainers) {
            list.add(t);
        }
        Collections.sort(list);
        int ans = 0;
        for(int i = 0; i < n; i++) {
            //找到大于等于它的最小值
            int tar = players[i];
            
            int l = 0, r = list.size() - 1;
            while(l < r){
                int mid = l + r >> 1;
                if(list.get(mid) >= tar) r = mid;
                else l = mid + 1;
            }
            if(tar > list.get(l)) break;
            list.remove(l);
            ans++;
            if(list.size() == 0) break;
        }
        return ans;
    }
}
```

### 三、[按位或最大的最小子数组长度](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/)

* 要找到每个以i为起点的最短子数组的或运算结果最大，那么必须让这个结果的1尽可能的更多。
* 用一个数组来记录一个数32位的每一位1最早出现的位置，枚举每个数时判断此时距离数组结尾（最右边）有1的数位最早出现的位置，这个位置要保证比自己的位置要远。
* 为了计算方便，我们从后往前枚举，遇到有1的位置就更新辅助数组（可以直接覆盖是因为当前的位置比之前记录的更早）。然后取32位里面的最大值(保证1的个数最多)为当前能够走到的最远位置，再更新答案即可。

```java
class Solution {
    public int[] smallestSubarrays(int[] nums) {
        int n = nums.length;
        int[] cnt = new int[32];
        Arrays.fill(cnt, -1);
        int[] ans = new int[n];
        for(int i = nums.length - 1; i >= 0; i--) {
            int tar = nums[i];
            int max = i;
            for(int j = 0; j < 32; j++) {
                if((tar >> j & 1) == 1) cnt[j] = i;
                if(cnt[j] != -1) max = Math.max(max, cnt[j]);
            }
            ans[i] = max - i + 1;
        }
        return ans;
    }
}

//滑动窗口做法,待更新
```

