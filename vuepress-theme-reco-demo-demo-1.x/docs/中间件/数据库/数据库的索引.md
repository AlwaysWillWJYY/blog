---
title: 数据库索引
date: 2022-04-06
categories:
 - 中间件
tags:
 - Mysql
 - 索引
---

### `索引`是帮助MySQL高效获取数据的排好序的数据结构

* 索引数据结构

·查找二叉树

·红黑树

·hash表

·B-Tree

![在这里插入图片描述](https://img-blog.csdnimg.cn/0d414281e6c04a019030280b5e227925.png)

·select * from t where col2 = 89;

如果没有建立索引，Mysql底层会从第一行开始逐行查找，会查六次

1）假设此时使用col2存储到一个查找二叉树的结构中：

查找二叉树的节点Node中是一个key-value的结构：key放的索引字段，value表示的是该字段所在行在磁盘上的地址（文件指针）
但是二叉树存储索引的时候会出现一些问题：假设此时是以col1作为索引建立二叉树：

![在这里插入图片描述](https://img-blog.csdnimg.cn/f0a7e1adc0c1446cb174dff34dc22904.png)

·select * from t where col1 = 6;（六次）

二叉树退化成了链表：因为一个数据库如果建立索引，那么索引也是海量的，没有办法一次加载到内存中，`而是放在磁盘上的
这样的查询结果会导致多次的磁盘IO，效率很低`.

2）使用红黑树来存储索引字段（红黑树是一种特殊的自平衡二叉树，这样可以解决退化成单链表的问题）

![在这里插入图片描述](https://img-blog.csdnimg.cn/ea4ae7e91672429c9618dac34e29d55f.png)

·select * from t where col1 = 6;（三次）

红黑树不适合作为存储索引的数据结构的原因？
当数据库的数据记录非常大时（假设一百万的数据），红黑树的高度会达到很高（2^n = 100,0000，假设h = 20）

**如果此时要查找的元素在叶子节点，此时需要进行的磁盘IO此时是很大的，性能非常差**

3）B树

![在这里插入图片描述](https://img-blog.csdnimg.cn/62325d84e8fd45b2aa720cd1b7a1afa0.png)

·B-Tree

·叶节点具有相同的深度，叶节点的指针为空
·所有索引元素不重复
·节点中的数据索引从左到右递增排列

4）B+树（B树的变种）

![在这里插入图片描述](https://img-blog.csdnimg.cn/d52c0672b31e4bdf8fe67eb8d1a52b7c.png)

·非叶子节点不存储data，只存储索引（冗余），可以放更多索引
·叶子节点包含所有索引字段
·叶子节点用指针连接，提高区间访问的性能

MySQL底层对每个节点的大小都是有默认大小的设置的16KB。
MySQL索引的节点不能太大，不然在加载到内存的过程中会浪费很多时间，反而会降低性能。

16KB/14B = 1170，一个非叶子节点可以存储大于1170个索引以及指向下一级的指针。

**data域中存储的是该索引字段所在行所有数据的封装或是该索引所在行存储在磁盘上的指针。**

### MyISAM索引文件和数据文件是分离的（非聚集）

```sql
select * from t where Col1 = 49;
```

执行过程：
1.MySQL先查看当前查找的字段是否是索引字段，如果是索引字段，就去MYI文件中去查找该元素；

2.首先是从常驻内存的根节点开始查起，然后将指向的节点加载到内存中不断进行查询；

3.找到了目标节点，获得到了对应节点的data数据，该数据是要查的数据行在磁盘中的地址指针；

4.到MYD文件中根据地址指针查找数据。

![在这里插入图片描述](https://img-blog.csdnimg.cn/93a6df81aba94c0ba195dc1878e10339.png)

`存储引擎是形容表的，表级别的。在建表的时候可以设置不同的存储引擎，默认的是InnoDB。

数据库表的内容是存储在磁盘上的。`

MyISAM表对应在磁盘上有三个文件：

* test_myisam.frm------表结构的定义数据

* test_myisam.MYD-----表中的数据

* test_myisam.MYI------存储索引数据

### InnoDB索引实现（聚集）

* 表数据文件本身就是按照B+Tree组织的一个索引结构文件；

* 聚集索引-叶节点包含了完整的数据记录；

* 为什么InnoDB表必须包含主键，并且推荐使用整形的自增主键？

建立InnoDB表时，如果没有指定主键，innodb会找到表中具有唯一性的一列创建主键；如果找不到这样的列，innodb会额外添加一列唯一性的作为主键。

为什么使用整形：如果使用UUID作为主键索引，而不是使用整形数据的话，比较起来会非常的慢，没有整形数据比较起来快。UUID的占用空间也比整形大。索引节点在叶子节点中从左到右是自增的，方便范围查询。比如：select * from t where col1 > 6，而对于hash作为底层建立数据库索引的话，对范围查找的支持非常差，而B+树会非常的方便。

为什么使用自增：如果不是自增的话，再插入数据的时候，可能会将数据插到某些中间节点，如果该节点已经满了，会导致节点的分裂，对性能影响较大。

* 为什么非主键索引结构叶子节点存储的是主键值？（一致性和节省存储空间）

![在这里插入图片描述](https://img-blog.csdnimg.cn/dd889ab4480b40299a44c9643ef17ba5.png)

对于主键索引而言，叶子节点存放的是完整的数据。将索引与数据进行合并了。

![在这里插入图片描述](https://img-blog.csdnimg.cn/25095a2171494c03af705ade1010c4a5.png)

InnoDB对应的磁盘文件：

·test_innodb_lock.frm----表结构文件

·test_innodb_lock.ibd----表中的数据和索引存放在一起


